SQL注入：
===

## 原理：
发生在应用程序与数据库层的安全漏洞。<br>

* 用户访问网页实际流程：
	* 输入url,经 DNS 解析为 IP，连接到目标服务器
	* 服务器从本地储存的 Web 程序中加载页面并解析
	* 页面连接位于数据访问层的 DBMS, 并执行 SQL 	--sql注入的发生环节
	* DBMS 执行 sql 后将结果返回给 Web Server
	* 业务逻辑层的 Web Server 将页面封装成 HTML 格式，并响应给浏览器
	* 浏览器解析 HTML 页面并展示给用户

## 危害：
* 猜解后台数据库，盗取网站敏感信息
* 绕过验证，登录网站后台
* 借助数据库的存储过程进行提权等操作

## 分类：
### 从协议角度分类：
* GET注入：<br>
通过在url中的自定义明文参数值来拼接sql，以获取所需信息。<br>
* POST注入：<br>
通过 Burp Suite 抓包的方式，抓取请求数据包，修改其中sql提取的属性的值，达到拼接sql的目的。<br>

### 从漏洞的利用类型类型分类：
* 布尔型注入：
	* 可拼接一个bool类型的判断
```
	示例： 
	http://... ?id=1 and substring(version(),1,1)=5
	如果服务端MySQL版本是5.x的话，那么页面的响应就和正常请求一样；
	如果不是5.x的话，就没有回显。
```
* 可联合查询注入：
	* 可拼接 union 子句
```
	示例：
	http://... ?id=1 union all select schema_name from information_schema.schemata
	通过union查询获取到想要的数据，前提是请求返回后能输出sql执行后查询到的内容。
```
* 基于时间延迟注入：
	* 时间盲注
```
	示例：
	http://... ?id=1 and sleep(3)

	可通过休眠等待时间来判断请求响应的时间。如网页响应时间相应变慢，则表示注入成功。

	适用场景： 页面不会返回错误信息时。
```
* 报错型注入：
	* 利用查询语句，获取数据库中额外的报错信息
```
	示例：
	利用 group by 的 duplicate entry 错误 来获取额外的报错信息。
	适用场景： 页面能够输出sql 报错信息，但不全面时。
```
* 可多语言查询注入：
	* 可拼接一个自定义的独立sql语句
```
	示例：
	http://... ?id=1;update t set name='a ' where id=1
	能够执行多条语句，非常危险。
```


## 1、初阶：

### 判断SQL注入点：
#### 难点：
* 如何发现Web应用存在sql注入漏洞
* 如何构建能够被成功执行的第一条语句

#### 关键点：
* 判断该访问目标URL是否存在sql注入？
	* 单引号判断法： <br>
		http://...?id=1'	若页面返回错误，则存在sql注入。<br>
		原因： 无论字符串还是整型，都会因为单引号个数不匹配而报错。<br>
	* 回归测试：<br>
		核心：推测后端sql语句的形态，尝试闭合sql语句。<br>
* 如果存在sql注入，属于哪种sql注入？
	* 数字型：<br>
		通常构造 and 1=1 或者 and 1=2 来判断<br>
	* 字符型：<br>
		通常构造 ' and '1'='1 或者 ' and '1' = '2 来判断<br>
``TIPS: 只要是带有参数的 动态网页 且此网页访问了数据库，那么就有可能存在sql注入。``

### 防御方式：
* 减少错误信息反馈
* 对输入的特殊符号进行转义（黑名单）<br>
	\x00 \n \r \ ' " \x1a  --若经自定义转椅函数处理成功，则使用转义后字符；若失败，则返回false<br>
* 对输入特殊词组进行过滤（黑名单）<br>
	常见的关键字： and or select union 空格... 进行过滤<br>


## 2、中阶：

### 时间盲注：基于时间延迟的注入
* 常用函数：
	* substr(a, b, c): 截取字符串 a 的 [b, c) 区间的字符
	* count(): 
	* ascii():
	* length():
	* left(a, b): 截取字符串 a 的前 b 个字符
	* sleep(n): 
* 拼接sql时将 sleep() 放在最后一个条件，当页面响应时间明显变长时，说明sleep（）执行成功。<br>	  由此可见：之前的判断语句都为true，以此可以通过自定义之前的判断来获取相应信息。<br>

### HTTP头注入：
针对请求头，如果不加以过滤或转义，在直接与数据库交互的构成中容易被利用进行sql注入攻击。<br>
#### 常见场景：
* 访问Web Server时，Web Server 会从 HTTP Header 中取出浏览器信息、IP地址、HOST信息等储存到数据库中。

### 报错注入：
#### 原理：
* 用于使sql语句报错的语法，返回的错误信息即是攻击者需要的信息。

#### 适用场景：
* 结果无回显但输出错误信息的情况。

#### 错误类型：
* BigInt 等数据类型溢出
* Xpath 语法错误
* count() + rand() + group_by() 导致重复
* 空间数据类型函数错误

### 堆叠注入：
#### 原理：
* 拼接多条sql语句，使多条语句顺序执行。

#### 适用场景：
* 篡改用户密码，待攻击者使用 账户及篡改的密码 登入系统后，再将密码改回。而已登入系统不退出。

#### 局限性：
* 回显通常为单一结果，因此只能看到第一条sql语句的执行结果；
* 使用堆叠注入前，我们需要预先知道一些数据库相关信息。 如：表名、列名...

### OOB注入： 带外通道技术 
#### 定义：
* DNS信道的迭代查询。
* 通过其他信道来获取数据。

#### 前提条件：
* 存在漏洞的系统  		
* 外围防火墙的出站请求	

#### 前期准备：
* 我们自己的服务器
* CEYE平台（用于监控请求）

#### 预备知识： 

* DNS 协议： Domain Name System
	* 将 域名 与 IP地址 建立映射关系的一个分布式数据库
	* 使用TCP 和 UDP 端口53
	* 每级域名限长 63 个字符，域名总限长 253 个字符。

* DNS 迭代查询原理：
	* 拥有一个域名；
	* 通过代理商设置 该域名 的 nameserver 为自己服务器的 IP；  --建立 域名与 IP 的映射
	* 在自己的服务器上搭建 DNS Server
	* 至此： 该域名及其子域名的查询都会推送到这台服务器上，同时这台服务器也能实时监控针对该域名的查询请求。

* DNS 查询流程： 用于 -> 本地 DNS 服务器 -> 根 DNS 服务器 -> 顶级 DNS 服务器 -> 权威 DNS 服务器
	* 根服务器：  13台（13个IP）
	* 顶级服务器： 对应一个顶级域名，如： com/net/org/cn/edu...
	* 权威服务器： 对应二级域名，如： qq.com/yahoo.com...    --注： 实际上二级域名就对应着具体的公司。
	* 还有很多子域名： www.qq.com/im.qq.com...

* 泛域名解析： 利用通配符的方式将所有的 次级域名 指向 同一个IP
	* 如： www.example.com 与 abc.example.com 都会访问到同一个站点。
	* 实现步骤： 配置域名解析时，在DNS服务器中配置如下记录： *.example.com 	-> 	IP

* tcpdump
	* 基于 Unix 系统的命令行数据包嗅探工具，可以抓取流动在网卡上的数据包。

* UNC 路径
	* 通用命名规则
	* Windows 主机默认存在， Linux 主机默认不存在
	* 格式： \\servername\sharename  	(\\服务器名\共享资源名)
	* 打印机、网络共享文件夹时，都会用到 UNC 填写地址。<br>
	  当我们使用 UNC 路径时，会对域名进行 DNS 解析<br>

* CEYE 平台
	* 用途： 可以监控 DNS 请求，并且配置了泛域名解析。
	* 使用步骤：
		* 注册 CEYE平台 账号（cete.io）
		* 登录平台，在 profile 页面可以看到分配给你的域名

### 混淆注入：（绕过WAF）
针对WAF（防火墙）<br>
#### 绕过类型的分类：
* 大小写绕过
	* 原理： 有些 sql 关键字会在发送请求时被过滤处理掉（简单的被替换为空）：<br>
			但 sql 语句是大小写不敏感的，当我们通过改变字符大小写来传递参数时，就可能不被过滤，从而实现攻击的目的<br>
* and/or 绕过：
	* 原理： 在请求时通过 符号 来替换 and or，来达到绕过的目的<br>
			and -> && 		or -> || 	<br>
* union 绕过：
	* 原理： 使用 || 来拼接 select 语句，达到 union 的功能。
* where 绕过：
	* 原理： 使用 limit 来替代 where
	* 示例：<br>
			select * from test where id = 1;<br>
			select * from test limit 0, 1;<br>
* limit 绕过：
	* 原理： 使用 group by 与 having 的组合来达到绕过的目的
	* 示例：<br>
			select name from test where id = 1 limit 1;<br>
			select id, min(name) from test group by id having id = 1;<br>
* group by 绕过：
	* 原理： 使用 group_concat 替换。
* select 及 单引号 绕过：
	* 原理： 使用 substr() 与 16进制数值 替换。<br>
			select -> substr()		目标字符 -> 16进制数值	<br>
* hex/unhex/substr 绕过：
	* 原理： 使用 binara() 替换。
* 空格 绕过：
	* 原理： 使用 注释符号 来替代空格。<br>
    * 示例： 
    		select name from test;<br>
    		select/**/name/**/from/**/test;<br>

* = 绕过：
	* 原理： 使用 like 替换 =
* 双写 绕过：
	* 原理： 使用 双写敏感关键字 的方式，来绕过关键字置空。
	* 示例：<br>
			union select 1,2,3,4,5			--union 被过滤置空<br>
			uniunionon select 1,2,3,4,5 	--中间的完整union被置空后，还会拼凑出一个union<br>
* 双重编码 绕过：
* 宽字节 绕过：
* 二次注入：
	* 原理： 来自数据库的输入同样不可信。
	* 示例：<br>
		当前端在注册账号时，账号为 admin'# <br>
		那么在进行其他的sql操作时，where条件就会变为 name = admin,后面的会被 # 注释掉<br>
	 		
	 	注册时：<br> 
	 		username = admin'#		password = 123<br>
	 	登录后，进行修改密码操作：<br>
	 		123 -> 456<br>
	 	预期执行语句：<br>
	 		update xxx set password='456' where username='admin'# and password='123';<br>
	 	实际执行语句：<br>
	 		update xxx set password='456' where username='admin'	--利用#注释掉后面的条件<br>
	 	所以，实际被修改密码的用户是 admin ，而不是admin'#。		达到篡改密码的目的<br>

### 防御方式：
* 代码与数据分离: 预编译（推荐）
* 禁止用护账号出现 特殊符号	

## 3、高级
### 自动化注入：
#### 原理： 依托工具来实现自动的sql注入
#### 工具介绍： 
##### sqlmap
* 集成了多种数据库识别及注入方式
* 多用于识别和利用Web应用程序注入漏洞的工具
* 优点：
	* 集成了大量的payload
	* 对检测与利用的自动化处理
* 特性： 
	* 对大部分DBMS的全面支持
	* 对六种sql注入技巧的全面支持
	* 直连数据库
	* 支持枚举功能
	* 支持密码hash
	* 支持dump数据
	* ...

##### FuzzDB + Burp
* FuzzDB: 一个开源的应用程序模糊测试数据库。
* 使用步骤：
	* 使用 Burp 拦截请求；
	* 加载指定的 FuzzDB 的攻击字典；
	* 执行请求，实现自动化注入。